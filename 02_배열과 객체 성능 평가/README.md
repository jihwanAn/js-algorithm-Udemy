# 배열과 객체의 성능평가

<br>

## 객체를 언제 쓸까?

- 정렬되어 있을 필요가 없을 때
- 값의 접근, 입력, 제거를 빠르게 하고 싶을 때
  - 삽입: O(1)
  - 제거: O(1)
  - 탐색: O(n) → 특정 정보가 값에 있는지 **모든 필드** 확인
  - 접근: O(1)
- 객체의 시작, 중간, 끝에 값을 집어넣을 수 없다. 단지 key를 통해 접근.

<br>

## 객체의 주요 메서드와 시간복잡도

`Object.keys` : O(n)

- 객체의 key들을 배열로 반환

`Object.values` : O(n)

- 객체의 value들을 배열로 반환

`Object.entries` : O(n)

- [[key, value], [key, value], ... ] 형태로 반환

`Object.hasOwnProperty()` : O(1)

- 속성이 있는지 여부를 boolean 형태로 반환, 특정 값을 원하면 상수 시간으로 접근 가능

<br>

## 배열은 언제 쓸까?

- 정렬이 필요할 때
- 맨 마지막에 추가하거나 값을 삭제하는 것은 빠름
  - 삽입: O(1) → 어디에 삽입하는지에 따라 다름
    - 마지막에 추가 `push` : O(1)
    - 맨 앞에 추가 `unshift` : O(N)
  - 제거: O(1) → 어떤 값을 제거하는지에 따라 다름
    - 마지막 값 제거 `pop` : O(1)
    - 맨 앞 값을 제거할 때 `shift` : O(N)
  - 탐색: O(N) → 객체와 동일(모든 엘리먼트 확인)
  - 접근: O(1) → 객체와 동일

<br>

## 배열의 주요 메서드와 시간복잡도

`concat` : O(n)

- 배열끼리 이어붙일 때 array1.concat(array2) 형태로 사용.

`slice` : O(n)

- 배열 일부를 가져옴

`splice` : O(n)

- 배열 일부를 삭제하거나 변경

`sort` : O(n \* logn)

- 정렬

`forEach/map/filter/reduce` : O(n)
